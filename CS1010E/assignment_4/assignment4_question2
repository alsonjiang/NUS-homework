from random import shuffle
from collections import Counter

'''
def binary_search(sorted_lst: list, target: int, itself: int) -> int:
    #itself parameter ensures it does not select itself in the input list
    low, high = 0, len(sorted_lst) - 1
    while low <= high:
        middle = (low + high) // 2
        if middle == itself: 
            break
        else:
            if sorted_lst[middle] == target: #target found
                return middle
            elif sorted_lst[middle] > target: #target is in left half
                high = middle - 1
            elif sorted_lst[middle] < target: #target is in the right half
                low = middle + 1
    return "not found" 
    #using a string as a false condition as false == 0
    #list[0] still has a value and it will create wrong matches
'''

'''
def matchResistors(R: tuple, n: int) -> list:

    seen = []
    result = []

    if R == ():
        return []
    else:
        #create a sorted list from unsorted tuple input
        lst_R = sorted(list(R))

    #the max resistor value
    max_val = max(lst_R)

    #count the number of each resistor
    resistor_counts = Counter(lst_R)

    #count the number of each resistor
    resistor_counts = Counter(lst_R)

    #find corresponding resistor pair for every resistor
    corresponding_resistor = [(n - value) for value in lst_R if (n - value) > 0]

    #search for matches, save to result
    for item, value in enumerate(corresponding_resistor):
        if value <= max_val:
            match = binary_search(lst_R, value, item) #search for a match in the original list, match is the index of the pair
            if match != "not found": #if index of the pair exists
                pair = lst_R[match] #pair == value of match index
                
                #minus 1 for the matched pair and original resistor
                resistor_counts[pair] -= 1
                resistor_counts[lst_R[item]] -= 1

                if resistor_counts[pair] >= 0 and resistor_counts[lst_R[item]] >= 0: 
                    result.append((pair, lst_R[item])) 

                if resistor_counts[pair] >= 0 and resistor_counts[lst_R[item]] >= 0: 
                    result.append((pair, lst_R[item])) 
    
    return result
'''

def matchResistors(R: tuple, n: int) -> tuple:

    result = []

    if R == () or R == []:
        return []
    else:
        lst_R = sorted(list(R))

    left, right = 0, len(lst_R) - 1

    while left < right and left <= len(lst_R) - 1 and right >= 0:
        left_value, right_value = lst_R[left], lst_R[right]

        if left_value + right_value == n:
            result.append((left_value, right_value))
            left += 1
            right -= 1
        
        elif left_value + right_value < n:
            left += 1

        else:
            right -= 1
    
    return result


#longList = ()
longList = [i for i in range(1, 1000000)]
shuffle(longList)
print(len(matchResistors(longList,10000)))
#print(matchResistors((75,80,90,77,88,91,60,74,73,70,55,93,59),150))


